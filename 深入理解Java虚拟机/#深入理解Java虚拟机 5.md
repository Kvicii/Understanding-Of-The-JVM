#深入理解Java虚拟机
# 5.虚拟机类加载机制
## 概述	
	* 类加载机制：虚拟机把描述类的文件从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成可被虚拟机直接使用的Java类型；
	* Java语言的类型加载、连接和初始化都是在程序运行过程期间完成的，虽然会增加一些性能开销但是增加了Java语言的灵活性；
## 类加载的时机
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/E91ECC81-6B1D-4CFF-9390-7C514A0616A7.png)
	* 类的整个生命周期分为7个阶段：加载、验证、准备、解析、初始化、使用、卸载，其中验证、准备、解析统称为连接；
	* 虚拟机没有强制约束类加载阶段的时间，但是严格规定初始化有且只有5种情况：
		1. 遇到new、getstatic、putstatic、invokestatic指令；
		2. 对类进行反射调用时如果类没有进行过初始化；
		3. 初始化时发现父类还没有进行初始化；
		4. 虚拟机启动指定的主类(包含main()的类)；
		5. 动态语言中MethodHandle实例最后解析结果REF_getStatic等的方法句柄对应的类没有初始化时；
	上述5种场景的行为称为对一个类的主动引用，除此之外所有的引用方式都不会触发初始化，称为被动引用；
	接口的初始化与类的初始化稍有不同：接口中不能使用static{}语句块，但编译器仍会为接口生成<clinit>()类构造器用于初始化接口中定义的成员变量。真正的区别出现在上述的场景3，当接口初始化时并不要求父接口全部完成初始化，只有真正使用到父接口的时候(如引用父接口的常量)才会初始化。
## 类加载的过程
### 加载
	* 通过一个类的全限定名来获取定义此类的二进制字节流；
	* 将这个字节流代表的静态存储结构转换为方法区运行时数据结构；
	* 在内存中创建一个代表这个类的java.lang.Class对象，作为方法区这个类数据的访问入口；
	非数组类的家在阶段可控性最强，可以自定义类加载器完成加载，但对数组而言本身不通过类加载器创建而是虚拟机直接创建，但数组的元素类型最终是需要靠类加载器加载。
	数组C的创建过程遵循以下规则：
	1. 如果数组元素类型是引用类型，数组C将在加载该类组件类型的类加载器的类名称空间上被标识；
	2. 如果数组元素类型不是引用类型，Java虚拟机会把数组C标记为与引导类加载器关联；
	3. 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那么数组类的可见性将默认为public；
	加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需格式存储在方法区中，然后在内存中实例化一个java.lang.Object类的对象(Object对象较为特殊，虽然是对象但是存放在方法区中)作为程序访问方法区中这些类型数据的外部接口。
	家在阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成连接阶段可能已经开始。
### 验证
	* 验证是连接阶段的第一步，其目的是确保Class文件字节流中的信息符合当前虚拟机的要求，不会危害虚拟机的自身安全；
	* 验证阶段非常重要，这个阶段是否严谨决定了Java虚拟机是否能够承受恶意代码的攻击；
	* 文件格式验证(基于二进制字节流)：主要目的是保证输入的字节流能正确的解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求，这个阶段是基于二进制字节流进行的，只有通过这个阶段后字节流才会进入内存方法区存储，后面的3个验证阶段都是及于方法区的存储结构进行的，不会再直接操作字节流；
	* 元数据验证(对类的元数据语义分析)：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息；
	* 字节码验证(对方法体语义分析)：最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为；
	* 如果一个类方法体的字节码没有通过字节码验证肯定是有问题的；但如果一个方法体通过了字节码验证并不能说明其一定是安全的，过多的验证时间都花在了字节码验证阶段，于是在JDK1.6之后javac编译器和Java虚拟机进行了优化：在方法体的Code属性中属性表增加了一项名为“StackMapTable”的属性，将类型推导转变为类型验证，这项属性描述了方法体中的所有基本块开始时本地变量表和操作栈应有的状态，在字节码验证期间，不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可，但该属性也有被篡改的可能，JDK1.6可以通过-XX:-UserSplitVerifier选项关闭这项优化，或使用-XX:+FailOverToOldVerifier要求在类型校验失败时退回到旧的类型推导方式进行校验，JDK1.7之后不允许退回；
	* 符号引用验证(对类自身以外的信息进行匹配性校验)：发生在虚拟机将符号引用转化为直接引用的时候，发生在连接的第三阶段解析，符号引用验证可以看做是对类自身以外的信息(常量池中的各种符号引用)进行匹配性校验，目的是确保解析动作能正常执行；
	验证阶段非常重要但不是必要的，如果代码已被反复使用和验证，可以通过-Xverify:none关闭大部分类型验证措施，缩短虚拟机类加载时间；
### 准备
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/4910AE6E-BC4A-42BF-904F-F090438DBB43.png)
	* 正式为变量分配内存并设置类变量初始值得阶段，这些变量所使用的内存都将在这个方法区中进行分配；
	* 此时内存分配仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，如果是static final直接赋值；
### 解析
	* 解析阶段是虚拟机将常量池内的符号引用(如CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等7种)转换为直接引用的过程；
	* 符号引用：可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄、它和虚拟机实现的内存布局相关，引用的目标必定在内存中存在；
	* 虚拟机规范没有明确规定解析发生的时间，只要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、putstatic字节码指令之前；
	* 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存从而避免解析动作重复进行，对于invokedynamic这条规则不成立，必须等到程序实际运行时到这条指令时解析动作才能进行；
	* 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_InvokeDynamic_info7中常量类型；
	* 解析包括类或接口的解析、字段解析、类方法解析、接口方法解析；
### 初始化
	* 是类加载过程的最后一步，真正开始执行类中定义的Java程序代码(字节码)；
	* 初始化阶段是执行类构造器<clinit>方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的；
	*  <clinit>方法与类的构造函数(类实例构造器(<init>)方法)不同，它不需要显式的调用父类构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已执行完毕；
	* <clinit>方法不需要显式的调用父类构造器，虚拟机保证在子类的<clinit>方法执行之前，父类的<clinit>方法已经执行完毕；
	* 父类中定义的静态语句块要优先于子类的变量赋值操作；
	* <clinit>方法对于类或接口不是必须的；
	* 执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的<clinit>方法；
	* 虚拟机会保证一个类的<clinit>方法再多线程环境中被正确加锁、同步，多个线程同时初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法，<clinit>方法初始化时加锁阻塞等待的，应当避免在<clinit>方法中有耗时很长的操作；
## 类加载器
	* 类加载阶段”通过一个类的全限定名获取描述此类的二进制字节流”这个动作放在虚拟机外部实现，实现该功能的代码模块称为类加载器；
	* 这时Java语言的一项创新，也是Java语言流行的原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩；
### 类与类加载器
	* 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间；
	* 比较两个类是否相等(如Class对象的equals方法、isAssignableFrom方法、isInstance方法)，只有在这两个类是由同一个类加载器加载的前提下才有意义；
### 双亲委派模型
	对于Java虚拟机类加载器分为两种：启动类加载器(虚拟机的一部分)和所有其他的类加载器(Java语言实现，独立于虚拟机外部，全部继承自java.lang.ClassLoader)，对于开发人员而言存在3中系统提供的类加载器：
	1. 启动类加载器(Bootstrap ClassLoader)：负责将<JAVA_HOME>\lib目录中或者被-Xbootclasspath指定的路径中并且能被虚拟机识别的类库加载到虚拟机内存，改加载器无法被Java程序直接引用；
	2. 扩展类加载器(Extension ClassLoader)：负责将<JAVA_HOME>\lib\ext目录中或者被java.ext/dirs系统变量所指定的路径中的所有类库，可以直接使用；
	3. 应用类加载器(Application ClassLoader)：是ClassLoader中的getSystemClassLoader()方法的返回值，也成为系统类加载器，负责加载用户路径(Classpath)指定的类库，可以直接使用，在没有自定义类加载器的情况下该加载器就是默认的类加载器；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2517FDCF-C893-4A80-948E-D33893E5B9EA.png)
	* 双亲委派模型要求除了最顶层的启动类加载器之外，其他的类加载器都应该有自己的父类加载器，通常使用组合的关系复用父类加载器的代码而不是继承的关系；
	* 工作过程：当一个类加载器收到类加载的请求，首先自己不会去尝试加载，而是把该请求委派给父类加载器去完成，所以最终的请求都会抛给启动类加载器，当父类加载器反馈无法完成加载请求时(在它的搜索范围内没有找到所需的类)，子类加载器才会尝试自己去加载；
	* 好处是Java类随着它的类加载器具备了一种带有优先级的层级关系，对保证Java程序稳定运行有着重要的影响；
	* 实现双亲委派的代码集中在java.lang.ClassLoader的loadClass()中；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7A22A411-C15F-495C-B167-8A14E6FACB66.png)
### 破坏双亲委派模型
	* 双亲委派模型是Java设计者推荐给开发者的类加载器实现方式，但不是一个强制性的约束模型；
	* 双亲委派模型的破坏分为3种：
		1. 双亲委派模型出现之前导致：JDK1.2之前只能重写loadClass()，引入后可以通过loadClass()调用findClass()进行控制；
		2. 由于双亲委派模型自身的缺陷导致：基础类回调用户的代码，如JNDI服务需要由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码。解决方案是引入了线程上下文类加载器(Thread Context ClassLoader)，可以通过java.lang.Thread类的setContextClassLoader()进行设置，如果创建线程时未设置，将会从父线程中继承一个，，如果在全局范围内没有设置，那这个类加载器默认就是应用程序类加载器，通过线程上下文类加载器父类加载器请求子类加载器去完成类加载的动作，违背了双亲委派模型的一般性原则；
		3. 用户对于程序动态性的追求导致：如OSGI实现模块化热部署(关键是自定义类加载机制的实现)，在OSGI环境下，类加载器不再是双亲委派模型中的树形结构，而是转为了网状结构；
## 总结
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7841328-8c57deda446a5284.png)
# 虚拟机字节码执行引擎
## 概述
	* 执行引擎是Java虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式；
	* 在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观；
	* 在不同的虚拟机实现里面，执行引擎在执行Java代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。
## 运行实战帧结构
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/063460AA-7E17-4745-984C-FCB97B62B7BD.png)
	* 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素；
	* 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程；
	* 栈帧需要分配多少内存在编译时就完全确定并写入到方法表的Code属性之中了，不会受到程序运行期变量数据的影响；
	* 对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作；
### 局部变量表
	* 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code属性的max_locals确定了该方法所需要分配局部变量表的最大容量；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/BC70127D-A4AE-442E-B29D-A6355952C9BB.png)
	* 其容量以变量槽(Variable Slot)为最小单位，虚拟机规范允许Slot的长度随处理器、操作系统或虚拟机的不同而发生变化；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7B186E0D-5AF2-4588-B9EB-3E9CE649E5FC.png)
	* 一个Slot可以存放一个32位以内的数据类型，包括boolean、byte、char、short、int、float、reference和returnAddress这八种类型；对于64位的数据类型(long和double)，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间；reference类型表示对一个对象实例的引用，没有明确说明长度和结构，一般是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，此引用直接或间接地查找到对象所属类型数据在方法区中存储的类型信息；returenAddress类型目前已经很少见，是为字节码指令jsr、jsr_w和wt服务的，很古老的虚拟机曾用这几条指令实现异常处理，现在已由异常表代替；
	* 虚拟机通过索引定位方式使用局部变量表，索引值范围从0开始至局部变量表最大的Slot数量，对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个；
	* 方法执行时，虚拟机是使用局部变量表完成参数值到参数列表的传递过程的，如果执行的是实例方法(非static方法)局部变量表第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数，其余参数按照参数表顺序排列占用从1开始的局部变量Slot；
	* 为了节省栈帧空间，局部变量表Slot是可以冲用的，Slot的复用直接会影响到系统的垃圾收集行为，GC Roots一部分的局部变量表会仍然保持着对于该变量的关联，这种关联没有被打断，如果后面的代码有耗时很长的操作，而引用的变量又占用了大量内存，此时手动将其设为null可以作为一种在极特殊情形下(对象占用内存大、此方法栈帧长时间不能回收、方法调用次数达不到JIT的编译条件)的“奇巧淫技”；
	* 局部变量不存在类变量的准备阶段；
### 操作数栈
	* 也常称为操作栈，它是一个`后入先出`栈；Code属性的max_stacks确定了其最大深度，操作数栈的每一个元素可以使任意的Java类型，包括long和double，32位数据类型占用的栈容量为1，64位数据类型占用的栈容量为2；
	* 当一个方法刚开始时，该方法的操作数栈为空，方法执行会有各种字节码指令往操作数栈写入/提取，即出栈/入栈；
	* 整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈；
	* 操作数栈中元素的类型必须与字节码指令的序列严格匹配，在类校验阶段的数据流分析中还要再次验证一次；
	* 概念模型中两个栈帧作为虚拟机栈的元素，是完全相互独立的，但在实现中会做一些优化处理，令两个栈帧出现一部分重叠，使下面栈帧部分操作数栈与上面栈帧部分局部变量表重叠在一起，这样在进行方法调用时就可以公用一部分数据无需进行额外的参数复制传递；
	* Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2BAA2650-8B4C-483B-8A43-6D2808F42195.png)
### 动态连接
	* 每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)；
	* Class文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析;而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接；
### 方法返回地址
	* 退出方法的方式：正常完成出口和异常完成出口；
	* 无论采用那种方式退出，方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回值可能需要在栈帧中保存一些数据用来帮助恢复它的上层方法的执行状态：正常退出调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个值；异常退出返回地址是通过异常处理表确定的，战阵一般不会保存这部分信息；
	* 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整PC计数器的值以只需方法调用指令后面的一套指令等；
### 附加信息
	* 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现；
	一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为战阵信息；
## 方法调用
	* 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程；
	* Class文件的编译过程中不包括传统编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂；
	* 解析调用一定是静态调用的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成，而分派调用可能是静态的也可能是动态的，根据分派依据的宗量数分为单分派和多分派，两两组合构成了静态单分派、静态多分配、动态单分派、静态多分派；
### 解析
	* 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析；
	* 在Java语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类；
	* 五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic；
	* 解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的；
	* 只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合该条件的有静态方法、私有方法、实例构造器、父类方法4类，除此之外还有被final修饰的方法，这种在类加载时就会把符号引用解析为该方法的直接引用，称为非虚方法，与之相反称为虚方法；
	* 解析和分派不是二选一的关系，它们是在不同层次上去筛选、确定目标方法的过程，静态方法虽然在类加载期间就会解析，但静态方法也是可以拥有重载版本的，重载版本的选择过程也是静态分配完成的；
### 分派
#### 静态分派
	* “Human man = new Man();”语句中Human称为变量的静态类型，后面的Man称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的`静态类型是在编译器可知的`；`而实际类型的变化在运行期才确定`，编译器在编译程序的时候并不知道一个对象的实际类型是什么；
	* 在方法接收者是确定对象的前提下，使用哪个重载版本完全取决于传入参数数量和数据类型，编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；
	* 所有`根据静态类型来定位方法执行版本的分派动作称为静态分派`，其`典型应用是方法重载`；
	* 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机执行的，往往只能找到一个“更加合适的”版本，主要原因是字面量不需要定义，所以字面量没有显式的静态类型，只能通过语言上的规则去理解和推断；
#### 动态分派
	* invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中`方法重写`的本质；我们把这种`在运行期根据实际类型确定方法执行版本的分派过程称为动态分派`；
#### 单分派与多分派
	* 方法的接收者与方法的参数统称为方法的`宗量`，根据分派基于多少种宗量，可以将分派分为单分派(根据一个宗量对目标方法进行选择)与多分派(根据多于一个宗量对目标方法进行选择)两种；`Java语言是一门静态多分派、动态单分派的语言`；
#### 虚拟机动态分派的实现
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/A6CF7F3D-4801-43BB-AF3D-680004626682.png)
	* 在方法区中建立一个虚方法表(Virtual Method Table)，使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕；
	* 虚方法表存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口；如果子类重写了这个方法，子类方法表中的地址会替换为指向子类实现版本的入口地址；
	* 为了程序上实现的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引号，在类型变换时，仅需要变更查找的方法表就可以从不同的虚方法表中按索引转换出所需的入口地址；
	* 除了分派调用的“稳定优化”手段方法表之外，还有内联缓存(Inline Cache)和基于“类型继承关系分析”(Class Hierarchy Analysis, CHA)技术的守护内联(Guarded Inlining)两种非稳定的“激进优化”手段获得更高的性能；
### 动态类型语言支持
	* JDK1.7发布增加的invokedynamic指令实现了“动态类型语言”支持，也是为JDK1.8顺利实现Lambda表达式做技术准备；
	* 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如JavaScript、Python等；
	* Java语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到Class文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在ECMAScript等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征；
	* JDK 1.7实现了JSR-292，新加入的java.lang.invoke包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为MethodHandle；
	* 从本质上讲，Reflection(反射)和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为Java语言服务，后者可服务于所有Java虚拟机之上的语言；
	* 每一处含有invokedynamic指令的位置都称为“动态调用点(Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_InvokeDynamic_info常量(可以得到引导方法、方法类型和名称)；
	* Invokedynamic指令与其他invoke指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的；
## 基于栈的字节码解释执行引擎
### 解释执行
	* 只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切；
	* Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现；
### 基于栈的指令集与基于寄存器的指令集
	* Java编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作；
	* 基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点；
### 基于栈的解释器执行过程
```
    public int calc(){
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;
    }
```
	上述代码的字节码表示
```
public int calc();
Code:
Stack=2, Locals=4, Args_size=1
0:bipush 100
2:istore_1
3:sipush 200
6:istore_2
7:sipush 300
10:istore_3
11:iload_1
12:iload_2
13:iadd
14:iload_3
15:imul
16:ireturn
```
	javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，作根据这些信息做以下示意图来说明执行过程中的变化情况：
	* 执行偏移地址为0的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/18F64661-A36A-467E-AED5-899AA99846E6.png)
	* 执行偏移地址为2的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/D38BB20D-60C3-4BC5-BD2F-CB82E2552675.png)
	* 执行偏移地址为11的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/E649B9C9-0091-4DCF-AEDC-FD7C5E596302.png)
	* 执行偏移地址为12的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/BDFBFC3D-E7F5-45B6-86D8-DFE65731CDE9.png)
	* 执行偏移地址为13的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3B1CC429-5D8D-470B-80FB-9BC623E3773C.png)
	* 执行偏移地址为14的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1E1AA76B-D189-44D7-8862-187B92A846B8.png)
	* 执行偏移地址为16的指令：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/DC6E60D7-11FE-47E7-9AD3-FA725F50EBA4.png)
	注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。
## 总结
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7841328-4dfa4892dd134321.png)
# 类加载及执行子系统的案例与实战
## 概述
	* 在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多；
	* 能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路；
## 案例分析
### Tomcat：正统的类加载器架构
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/FA7E0C4C-B68F-41FF-976A-0047CD2CA7CB.png)
	* Java Web服务器：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的Web应用程序影响；要支持JSP生成类的热替换；
	* 上图中，灰色背景的三个类加载器是JDK默认提供的类加载器，而CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader是Tomcat自己定义的类加载器，分别加载/common/* (可被Tomcat和Web应用共用)、/server/* (可被Tomcat使用)、/shared/* (可被Web应用使用)和/WebApp/WEB-INF/* (可被当前Web应用使用)中的Java类库，Tomcat 6.x把前面三个目录默认合并到一起变成一个/lib目录(作用同原先的common目录)；
### OSGI：灵活的类加载架构
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/B45D0863-E1AE-4948-B5E9-AEA75B4375A5.png)
	* OSGI的每个模块称为Bundle，可以声明它所依赖的Java Package(通过Import-Package描述)，也可以声明它允许导出发布的Java Package(通过Export-Package描述)；
	* 除了更精确的模块划分和可见性控制外，引入OSGI的另外一个重要理由是基于OSGI的程序很可能可以实现模块级的热插拔功能；
	* OSGI的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患；
### 字节码生成技术与动态代理的实现
	* 在Java里面除了javac和字节码类库外，使用字节码生成的例子还有Web服务器中的JSP编译器、编译时植入的AOP框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的；
	* 动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中；
	* 以下的例子中生成的代理类“$Proxy0.class”文件可以看到代理为传入接口的每一个方法统一调用了InvocationHandler对象的invoke方法；其生成代理类的字节码大致过程其实就是根据Class文件的格式规范去拼接字节码；
```
public class DynamicProxyTest {

    interface IHello {
        void sayHello();
    }

    static class Hello implements IHello {
        @Override
        public void sayHello() {
            System.out.println(“Hello world”);
        }
    }

    static class DynamicProxy implements InvocationHandler {
        Object originalObj;

        Object bind(Object originalObj) {
            this.originalObj = originalObj;
            return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(“Welcome”);
            return method.invoke(originalObj, args);
        }
    }

    public static void main(String[] args) {
        // add this property to generate proxy class file
        System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);

        IHello hello = (IHello) new DynamicProxy().bind(new Hello());
        hello.sayHello();
    }
}
```
### Retrotranslator：跨越JDK版本
* Retrotranslator的作用是将JDK1.5编译出来的Class文件转变为可以在JDK1.4或JDK1.3部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作；
* JDK升级通常包括四种类型：编译器层面的做的改进、Java API的代码增强、需要在字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator只能模拟前两类，第二类通过独立类库实现，第一类则通过ASM框架直接对字节码进行处理；
## 实战：自己动手实现远程执行功能
	* 目标：不依赖JDK版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端；
	* 思路：如何编译提交到服务器的Java代码(客户端编译好上传Class文件而不是Java代码)、如何执行编译之后的Java代码(要能访问其他类库，要能卸载)、如何收集Java代码的执行结果(在执行的类中把System.out的符号引用替换为我们准备的PrintStream的符号引用)；
	* 具体实现：HotSwapClassLoader用于实现同一个类的代码可以被多次加载，通过公开父类ClassLoader的defineClass实现；HackSystem是为了替换java.lang.System，它直接修改Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串；ClassModifier涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在ByteUtils类中；经过ClassModifier处理过的byte[]数组才会传给HotSwapClassLoader.loadByte方法进行类加载；而JavaClassExecutor是提供给外部调用的入口；
```
public class JavaClassExecutor {

    public static String execute(byte[] classByte) {
        HackSystem.clearBuffer();
        ClassModifier cm = new ClassModifier(classByte);
        byte[] modifiedBytes = cm.modifyUTF8Constant("java/lang/System", "org/fenixsoft/classloading/execute/HackSystem");
        HotSwapClassLoader hotSwapClassLoader = new HotSwapClassLoader();
        Class clazz = hotSwapClassLoader.loadByte(modifiedBytes);
        try {
            Method method = clazz.getMethod("main", new Class[]{String[].class});
            method.invoke(null, new String[]{null});
        } catch (Throwable t) {
            t.printStackTrace(HackSystem.out);
        }

        return HackSystem.getBufferString();
    }
}
```
	用于测试的JSP：
```
<%@page import=“java.lang.*” %>
<%@page import=“java.io.*” %>
<%@page import=“org.fenixsoft.classloading.execute.*” %>

<%
InputStream is = new FileInputStream(“c:/TestClass.class”);
byte[] b = new byte[is.available()];
is.read(b);
is.close();

out.println(JavaClassExecutor.execute(b));
%>
```
## 总结
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7841328-dd93ea21366f7745.png)