#深入理解Java虚拟机
# 4.类文件结构
## 概述
	程序编译成二进制机器码有计算机执行已不再是唯一选择，越来越多的语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。
## 无关性的基石
	* Java诞生之初的著名口号：一次编写，到处运行(Write Once, Run Anywhere)，其最终实现在操作系统的应用层，Sun公司和其他众多虚拟机厂商发布的多种虚拟”机都可以载入一种平台无关的字节码；
	* 字节码是构成平台无关的基石；
	* 虚拟机的语言无关性也被得到重视，JVM设计者设计之初就考虑到其他语言运行在Java虚拟机的可能性，如今已有多种语言可以在JVM上运行：比如Clojure、Groovy、JRuby、Jython、Scala；
	* 虚拟机和字节码的存储格式是构成语言无关性的基石，Java虚拟机和不包括Java在内的任何语言绑定，它至于Class文件相关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/269645CA-44D2-4A3B-8361-BD34F73EF180.png)
	Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码所能提供的语义描述能力肯定比Java语言更加强大，这也为其他语言实现一些有别于Java语言的特性提供了基础。
## Class类文件结构
	* Class文件是一组以8位字节为基础单位的二进制流(可能是磁盘文件，也可能是类加载器直接生成的)，各个数据项目严格按照顺序紧凑的排列，中间没有任何分隔符。但需要8位字节以上空间的数据项时，会按照高位在前的方式分隔成若干个8位字节进行存储；
	* Class文件格式采用了一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表；
		1. 无符号数：属于基本数据类型，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值(u1、u2、u4和u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数)；
		2. 表：由多个无符号数或者其他表作为数据构成的复合数据结构，以”_info”结尾，用于描述有层次关系的复合结构的数据；
		3. 无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。
	* 下表中的数据项在Class文件中无论是顺序还是数量，甚至于数据存储的字节序的细节都是被严格限定的：什么字节代表什么含义、长度是多少、先后顺序如何都不允许改变；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/C84E3AB6-D21C-4B94-B53D-59F468F6F6B9.png)
	下面以一个简单的Java文件来学习其中各个部分的含义：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/79B23567-45E0-4ADC-A56D-6941BBCC5367.png)
	16进制文件如下：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/B862E2CD-29B7-432B-811C-DDAC2D16A86C.png)
	使用javap -verbose输出Class文件信息：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/D58B120C-1893-45FA-8ACC-C74965364296.png)
### 魔数和版本
	* Class文件的头4个字节，唯一作用是确定文件是否为一个可被虚拟机接受的Class文件，固定为”0xCAFEBABE”；
	* 第5和第6个字节是次版本号，第7和第8个字节是主版本号(0x0034为52，对应JDK版本1.8)，能向下兼容之前的版本，无法运行后续的版本；
### 常量池
	* 常量池可以理解为Class文件之中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项之一；
	* 由于常量池中的常量数量不固定，因此需要在常量池前放置一项u2类型的常量池容量计数器，该值是从1开始的，上图的0x0016为十进制的22，代表常量池中有21项常量，索引值范围为1~21；
	* 常量池主要存放两大类常量：字面量(Literal，接近Java的常量概念，比如文本字符串和final常量等)和符号引用(Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符)；
	* Java代码在javac编译时不会有”连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接；所以在Class文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中；
	* JDK1.7中常量池共有14种不同的表结构数据，这些表结构开始的第一位是一个u1类型的标志位，代表当前常量的类型：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/CDBA20AE-5026-496A-8ACE-DD77749752DE.png)
	* 之所以说常量池是最繁琐的数据就是因为这14种常量类型都有自己的结构，可以结合下图中各个表结构的说明和之前使用javap解析的文件内容一起看：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7DCE4F62-1421-4960-9AFE-D5F59CA79ECB.png)
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/E025AF20-2F5B-459B-8FA0-20FE7E2F2FCA.png)
	* 第1项：0x0A(10标志类中方法的符号引用)，0x0004(指向声明方法的类描述符索引为4)，0x0012(指向名称及类型描述符索引18)；
	* 第2项：0x09(9字段的符号引用)，0x0003(指向声明字段的类或者接口描述符的索引项3)，0x0013(指向字段描述符的索引项19)；
	* 第3项：0x07(7类或接口的符号引用)，0x0014(指向全限定名常量项的索引20)；
	* 第4项：0x07(7类或接口的符号引用)，0x0015(指向全限定名常量项的索引21)；
	* 第5项：0x01(1UTF-8编码的字符串)，0x0001(UTF-8编码的字符串占用字节数1)，
```
	6D(字符”m”)；
```
	* 第6项：0x01(1UTF-8编码的字符串)，0x0001(UTF-8编码的字符串占用字节数1)
```
	49(字符”I”)；
```
	* 第7项：0x01(1UTF-8编码的字符串)，0x0006(UTF-8编码的字符串占用字节数6)
```
	3C 69 6E 69 74 3E(字符”<init>”)；
```
	* 第8项：0x01(1UTF-8编码的字符串)，0x0003(UTF-8编码的字符串占用字节数3)，
```
	28 29 56(字符”()V”)；
```
	* 第9项：0x01(1UTF-8编码的字符串)，0x0004(UTF-8编码的字符串占用字节数4)，
```
	43 6F 64 65(字符”Code”)；
```
	* 第10项：0x01(1UTF-8编码的字符串)，0x000F(UTF-8编码的字符串占用字节数15)，
```
	4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65(字符”LineNumberTable”)；
```
	* 第11项：0x01(1UTF-8编码的字符串)，0x0012(UTF-8编码的字符串占用字节数18)，
```
	4C 6F 63 61 6C 56 61 72 69 61 62 6C 65 54 61 62 6C 65
(字符”LocalVariableTable”)；
```
	* 第12项：0x01(1UTF-8编码的字符串)，0x0004(UTF-8编码的字符串占用字节数4)，
```
74 68 69 73(字符”this”)；	
```
	* 第13项：0x01(1UTF-8编码的字符串)，0x002E(UTF-8编码的字符串占用字节数46)，
```
4C 63 6F 6D 2F 73 70 72 69 6E 67 63 6C 6F 75 64 2F 7A 75 75 6C 2F 54 68 72 65 61 64 54 65 73 74 2F 42 79 74 65 63 6F 64 65 54 65 73 74 3B
(字符”Lcom/spring/cloud/zuul/ThreadTest/BytecodeTest;”)
```
	* 第14项：0x01(1UTF-8编码的字符串)，0x0003(UTF-8编码的字符串占用字节数3)，
```
	69 6E 63(字符”inc”)；
```
	* 第15项：0x01(1UTF-8编码的字符串)，0x0003(UTF-8编码的字符串占用字节数3)，
```
28 29 49(字符”()I”)；
```
	* 第16项：0x01(1UTF-8编码的字符串)，0x000A(UTF-8编码的字符串占用字节数10)，
```
53 6F 75 72 63 65 46 69 6C 65(字符”SourceFile”)；
```
	* 第17项：0x01(1UTF-8编码的字符串)，0x0011(UTF-8编码的字符串占用字节数17)，
```
42 79 74 65 63 6F 64 65 54 65 73 74 2E 6A 61 76 61
(字符”BytecodeTest.java”)；
```
	* 第18项：0x0C(12字段或方法的部分符号引用)，0x0007(指向该字段或方法名称常量项索引7)，0x0008(指向该字段或方法描述符常量项索引8)；
	* 第19项：0x0C(12字段或方法的部分符号引用)，0x0005(指向该字段或方法名称常量项索引5)，0x0006(指向该字段或方法描述符常量项索引6)；
	* 第20项：0x01(1UTF-8编码的字符串)，0x002C(UTF-8编码的字符串占用字节数44)，
```
63 6F 6D 2F 73 70 72 69 6E 67 63 6C 6F 75 64 2F 7A 75 75 6C 2F 54 68 72 65 61 64 54 65 73 74 2F 42 79 74 65 63 6F 64 65 54 65 73 74
(字符”com/springcloud/zuul/ThreadTest/BytecodeTest”)；
```
	* 第21项：0x01(1UTF-8编码的字符串)，0x0010(UTF-8编码的字符串占用字节数16)，
```
6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74
(字符”java/lang/Object”)；
```
### 访问标志
	* 紧接常量池之后，用于标识类或接口的访问信息；
	* 访问标志一个有16个标志位，目前只采用了8位，本例中为0x0021 = 0x0001 | 0x0020，表示一个public的普通类
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/E0E29E73-3EF0-4976-9EF4-8D50B8BB435C.png)
### 类索引、父类索引、接口索引集合
	* 类索引：u2类型数据，确定类的全限定名，本例中为0x0003，指向常量池中第3项；
	* 父类索引：u2类型数据，确定父类的全限定名，本例中为0x0004，指向常量池中第4项；
	* 接口索引计数器：u2类型数据，表示接口索引集合的容量，本例中为0x0000，说明没有实现接口；
	* 接口索引集合：一组u2类型数据的集合，确定实现的接口(对于接口而言是extend的接口)，本例不存在；
### 字段表集合
	本例中0x0001表示这个类只有一个字段。
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/29F40ECC-79BA-4B97-A42A-7F932AC29FD8.png)
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/18012429-2A85-4301-90AF-9DF54252E0B7.png)
	* 用于描述接口或者类中声明的变量：包括类级变量和实例级变量，但不包括方法内部声明的局部变量，不会列出从父类和超类继承而来的字段但有可能列出原本代码中不存在的字段(内部类中为了保持对外部类的访问性会自动添加指向外部类实例的字段)；
	* 对于Java语言字段无法重载，但对于字节码而言如果字段的描述符不一致但字段重名是被允许的；
	* 字段修饰符存放在u2类型的access_flag中，本例中0x0002表示该字段被private修饰；
	* 字段名称索引存放在u2类型的name_index中，本例中0x0005表示常量池的第5项；
	* 字段描述符索引存放在u2类型的descriptor_index中，本例中0x0006表示常量池的第6项；
	* 字段属性计数器：本例为0x0000不存在；
	* 字段属性集合：本例不存在；
	简单名称、描述符、全限定名概念：
		1. 全限定名：本例中的”Lcom/spring/cloud/zuul/ThreadTest/BytecodeTest;”是这个类的全限定名，只是把类全名的”.”替换成了”/”，连续的多个全限定名之间不产生混淆的方式是在最后加一个”;”，表示全限定名结束；
		2. 简单名称：指没有类型和参数修饰符的方法或字段名称，本例中的inc()和m字段的简单名称为”inc”和”m”；
		3. 描述符：描述字段的数据类型、方法的参数列表(包括数量、类型、顺序)和返回值：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/005C931C-DD31-4FDA-832C-C4AFA240793E.png)
	对于数组类型，每一维度使用一个前置的”[”字符描述，例如”java.lang.String[][]”将被记录为”[[Ljava/lang/String”；
	对于方法，按照先参数列表，后返回值的顺序描述，例如”int index(String a, int b, char[][] arr)”记录为”(Ljava/lang/StringI[[C)I”；
### 方法表集合
	本例中0x0002表示这个类有两个方法，分别是编译器添加的实例构造器<init>和源码中的inc()，第一个方法的访问标志位0x0001(public方法)，名称索引值0x0007(指向常量池第7项，”<init>”)，描述符索引值0x0008(指向常量池第8位)，属性表计数器0x0001(有1个属性)，属性名称索引为0x0009(常量池第9项，”Code“)。
	由属性表章节Code属性可知：属性值的长度为41(0x0000002F表示47，但需要减去属性名称索引和属性长度固定的6个字节长度)，操作数栈深度的最大值为1(0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度)，局部变量表所需要的存储空间为1个Slot(0x0001，Slot是内存分配的最小单位)，字节码长度为5(0x00000005)，分别为2A(aload_0，将第0个Slot中为reference类型的本地变量推送到操作数栈顶)、B7(invokespecial，以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它父类的方法，后面接着一个u2的参数指向常量池的方法引用)、0x0001(表示常量池的第1项，即Object类的<init>方法)、B1(对应的指令为return，返回值为void)；显式异常表为空(0x0000，计数器为0)；该Code属性还内嵌2个属性(0x0002)，属性的名称索引为0x000A(即“LineNumberTable”属性，用于记录对应的代码行数)，该内嵌属性的长度为6(0x00000006)，对应的行数信息为源码的第8行(0x000100000008)，属性名称索引为0x000B(即“LineVariableTable”属性，用于记录变量表信息)，该内嵌属性的长度为12(0x0000000C)，对应的行数信息为源码的第5行(0x000100000005)；
	第二个方法的访问标志是0x0001(public方法)，名称索引值为0x000E(常量池第14项，“inc”)，描述符索引值为0x000F(常量池第15项，“()I”)，属性表计算器为0x0001(有一项属性)，属性名称索引为0x0009(常量池第9项，“Code”)；
	由属性表章节Code属性可知：属性值的长度为43(0x00000031表示49，但需要减去属性名称索引和属性长度固定的6个字节长度)，操作数栈深度的最大值为2(0x0002)，局部变量表所需要的存储空间为1个Slot(0x0001)，字节码长度为7(0x00000007)，分别为2A(aload_0)、B4(getfield，后面接着一个u2的参数指向常量池的属性引用)、0x0002(表示常量池的第2项，即TestClass类的m属性)、04(对应的指令为iconst_1)、60(对应的指令为iadd，整形求和)、AC(对应的指令为ireturn，返回值为整形)；显式异常表为空(0x0000，计数器为0)；该Code属性还内嵌2个属性(0x0002)，属性的名称索引为0x000A(即“LineNumberTable”属性，用于记录对应的代码行数)，该内嵌属性的长度为6(0x00000006)，对应的行数信息为源码的第13行(0x00010000000D)，属性的名称索引为0x000B(即“LineVariableTable”属性，用于记录变量表信息)，该内嵌属性的长度为12(0x0000000C)，对应的行数信息为源码的第7行(0x000100000007)；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/29F40ECC-79BA-4B97-A42A-7F932AC29FD8.png)
	* 和字段表集合的内容几乎一致，仅在访问标志和属性表集合的可选项中有所区别；
	* 方法中的代码经编译产生字节码指令后，存放在方法属性表集合中一个名为Code属性中；
	* 父类方法在子类没有被Override，方法表集合中就不会出现来自父类的方法信息，但可能会出现由编译器自动添加的方法(类构造器”<client>”方法和实例构造器“<init>”方法)；
	* Java语言重载一个方法除了名称相同之外，还必须要求有一个与原方法不同的特征签名(Java层面的特征签名只包括方法名称、参数顺序及参数类型在常量池中的字段符号引用的集合)，因此Java语言的无法仅仅靠返回值的不同对已有方法重载；但Class文件特征签名范围大一些(字节码层面的特征签名除了Java层面的特征签名定义外，还包括方法的返回值和受查异常表)，所以在字节码文件中只要描述符不完全一致是可以共存的；
### 属性表集合
	* 在Class文件、字段表、方法表都可以携带自己的属性表集合；
	* 属性表集合的限制相比于Class文件的其他数据项目要求限制较为宽松，不再要求严格的顺序，只要属性名不重复即可；
	* 对于每个属性名称只需要从常量池中引用一个CONSTANT_Utf8_info类型的常量表示，属性值结构完全自定义；
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/E1F9B180-77E7-4769-B135-A698185192A2.png)
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/9C2F5C56-1DEA-4F4E-9407-E4A2DA52A549.png)
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/8802D282-627A-4EDE-9EAA-499AC022407E.png)
	本例中Class文件中最后一段：0x0001表示该Class有一个属性，0x0010表示属性名索引为第16项(对应”SourceFile“)，0x00000002表示该属性长度为2，0x0011表示该类的SourceFile名称为第17项，即”BytecodeTest.java“。
#### Code属性
	Java程序方法体中的代码经javac编译后，字节码指令放在Code属性，但并不是所有的方法都有该属性(接口或抽象类中的方法)，其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/F52FCE51-82F6-42AC-BE8F-CE524B470E74.png)
		* attribute_name_index：代表属性名称；
		* attribute_length：属性值长度，属性名称索引与属性定长6个字节，属性值长度 = 属性表长度 - 6；
		* max_stack：操作数栈最大深度；
		* max_locals：局部变量表所需存储空间，单位是Slot(虚拟机为局部变量分配内存使用的最小单位)，每个局部变量占用1个Slot，double和long64位数据类型需要2个Slot存放，可以重用；
		* code_length/code：存储Java源程序编译后生成的字节码指令；
		* exception_table_legth/exception_table：异常处理表集合，不是必须存在的，格式如下：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/997E82D2-6BA1-433F-A71D-246F6F63D62D.png)
	含义为字节码在第start_pc行到end_pc行之间(不包含end_pc)如果出现了catch_type或其子类的异常，转到handler_pc行进行处理，当catch_tpy为0时表示任何异常都要转到handler_pc处理，Java使用异常表而不是跳转命令实现Java异常及finally处理机制；
#### Execptions属性
	方法描述时throws关键字后面列举的异常，与Cdde属性平级，和Code属性里的异常表不同。其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7BF87CAC-4CF5-4A3F-A35A-C342E53089F9.png)
	* number_of_exceptions/exception_index_table：可能抛出多少种受查异常，每一种使用一个exception_index_table表示；
#### LineNumberTable属性
	用于描述Java源码行号与字节码行号之间的对应关系，它不是必须的，可以通过javac -g:none取消或javac -g:lines生成。没有该信息的影响是运行时抛异常不会显示出错的行号，代码调试时无法按照源码行来设置断点。其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/DC1D1394-B825-45A5-9962-4220640E98B7.png)
	* line_number_info是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包含了start_pc和line_pc两个u2类型数据项，前者是字节码行号，后者是Java源码行号；
#### LocalVariableTable属性
	用于描述栈帧中局部变量与Java源码中定义的变量之间的关系，它不是运行时必须的，可以通过javac -g:none取消或javac -g:vars生成。如果没有这个属性，所有的参数名称都会丢失，取之以arg0、arg1这样的占位符来替代，其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/EE826487-89BC-4BB7-B953-C0723AE0CE97.png)
	其中local_variable_info项代表了一个栈帧与源码中局部变量的关联：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2F140BB8-9AC7-4620-8316-2D9E9F4B52C5.png)
	* start_pc和length代表局部变量生命周期开始的字节码偏移量及其作用的范围长度；
	* name_index和descriptor_index指向常量池中的CONSTANT_Utf8_info型常量的索引，分别代表局部变量的名称及局部变量的描述符；
	* index是这个局部变量在栈帧局部变量表中Slot中的位置，当变量数据类型为64位时，占用的Slot为index和index+1两个；
#### SourceFile属性
	用于记录生成这个Class的源码文件名称，这个属性也是可选的，其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1BFF5729-885C-4D8D-AA90-BFFA1C0E6CE1.png)
	* sourcefile_index是指向常量池中CONSTANT_Utf8_info型敞亮的索引，值为源码的文件名；
#### ConstantValue属性
	作用是通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以用这个属性。对于非static类型的变量的赋值是在实例构造器<init>方法中进行的；而对于类变量有两种方式：在类构造器<clinit>方法中或者使用ConstantValue属性。目前Sun javac编译器的选择是：同时使用final和static修饰的变量且为基本数据类型或String类型使用ConstantValue属性初始化，否则使用<clinit>初始化，其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/F86F7E98-206D-4173-A0E7-2ECA1F140F63.png)
	* ConstantValue为定长属性，attribute_length数据项值必须固定为2；
	* constantvalue_index代表常量池中一个字面量常量的异常索引，可能是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info中的一种；
#### InnerClass属性
	用于记录内部类与宿主类之间的关联，其属性表结构：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/58E8C297-91CB-4C9C-9DD4-0087D3186A25.png)
	* number_of_classes代表需要记录多少个内部类信息，每一个内部类信息都由一个inner_classes表描述：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/42D59D50-2B44-4CBE-B623-F647D413954A.png)
	* inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表内部类和宿主类的符号引用；
	* inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表内部类的名称，如果是匿名内部类置值为0；
	* inner_class_access_flags是内部类的访问标志，类似于类的access_flags，取值范围如下：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/ADCBE3C4-4940-4A92-94BA-EBA0EEB2C713.png)
#### Depreccated/Synthetic属性
	Deprecated(不推荐使用)和Synthetic(不是由Java源码直接产生编译器自行添加的，有两个例外是实例构造器<init>和类构造器<clinit>)这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中attribute_length的数据值必须为0x00000000。
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/11429D7D-BAF4-4D64-9DAA-7AD6C8650B1B.png)
#### StackMapTable属性
	这是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/EF7467A3-CBEC-4E09-BC45-BF1218288EB1.png)
#### Signature属性
	一个可选的定长属性，在JDK 1.5发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息。这主要是因为Java的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过Signature属性，Java的反射API能够获取泛型类型。
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/02F9F9C3-FD7E-42EF-9486-5B7C20DF26D2.png)
#### BootstrapMethods属性
	一个复杂的变长属性，位于类文件的属性表中，用于保存invokedynamic指令引用的引导方法限定符，如果某个类文件结构的常量池中曾经出现过一次或多次CONSTANT_InvokeDynamic_info类型常量，那么该类文件结构属性表中必须只能存在一个BootsrapMethods属性，
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/FCFA908A-A2A8-4C22-8E77-4FA02DBF199D.png)
	其中引用到的bootstrap_method结构如下：
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3E2D0BEF-8478-4ACA-A83C-0437B99514B7.png)
	* num_bootstrap_arguments值给出了bootstrap_methods[]数组中引导方法限定符的数量，bootstrap_methods[]数组的每个成员包含一个指向常量池CONSTANT_MethodHandle结构的索引值，代表一个引导方法，还包含了这个引导方法静态参数的序列(可能为空)；
	* bootstrap_methods[]数组每个成员必须包含3项内容：
		1. bootstrap_method_ref：值必须是一个对常量池的有效索引，常量池该索引出的值必须为CONSTANT_MethodHandle_info结构；
		2. num_bootstrap_arguments：值为bootstrap_methods[]数组中成员的数量；
		3. bootstrap_methods[]：每个成员必须是一个对常量池的有效索引，常量池在该位置处必须是下列结构之一：CONSTANT_Class_info、CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info；
### 字节码指令简介
	Java虚拟机指令由一个字节长度、代表着特定含义的数字(操作码)以及跟随其后的零至多个代表此操作所需参数(操作数)构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码。
	在指令集中大多数的指令都包含了其操作对应的数据类型信息，如iload指令用于从局部变量表中加载int类型的数据到操作数栈中。
	* 加载和存储指令：iload/iload_<n>等(加载局部变量到操作数栈)、istore/istore_<n>等(从操作数栈存储局部变量表)、bipush/sipush/ldc/iconst_<n>(加载常量到操作数栈)、wide(扩充局部变量表访问索引)；
	* 运算指令：没有直接支持byte、short、char和boolean类型的算输指令而采用int代替，iadd/isub/imul/idiv加减乘除、irem求余、ishl/ishr位移、ior按位或、iand按位与、ixor按位异或、iinc局部变量自增、dcmpg/dcmpl比较大小；
	* 类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f；
	* 对象创建与访问指令：new创建对象实例、newarray/anewarray/multianewarray创建数组、getfield/putfield/putstatic访问类或实例字段、baload/iaload/aaload把一个数组元素加载到操作数栈、bastore/iastore/aastore将一个操作数栈的值存储到数组元素中、arraylength获取数组长度、instanceof/checkcast检查类实例类型；
	* 操作数栈管理指令：pop/pop2一个或两个元素出栈、dup/dup2复制栈顶一个或两个数组并将复制值重新压入栈顶、swap交换栈顶两个数值；
	* 控制转移指令：ifeq/iflt/ifnull条件分支、tableswitch/lookupswitch符合条件分支、goto/jsr/ret无条件分支；
	* 方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic方法调用、ireturn/lreturn/areturn/return方法返回；
	* 异常处理指令：athrow；
	* 同步指令：monitorenter/monitorexit；
### 共有设计和私有实现
	* Java虚拟机的实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的含义；
	* 一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现作出修改和优化；
	* 虚拟机的实现方式主要有两种：将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机CPU的本地指令集；
### Class文件结构的发展
	* Class文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容；
	* Class文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要基础；
## 总结
![](%23%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/7841328-fcb63165eea60316.png)